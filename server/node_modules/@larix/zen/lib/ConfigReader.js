"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var merge = require("webpack-merge");
var createRequire_1 = require("./createRequire");
var EnhancedError_1 = require("./EnhancedError");
var inferConfig_1 = require("./inferConfig");
var Stack_1 = require("./Stack");
var ConfigReader = (function () {
    function ConfigReader(zen, plugins) {
        this.zen = zen;
        this.plugins = plugins;
    }
    ConfigReader.prototype.readConfig = function (options) {
        var filePath = options.filePath, inferedConfig = options.inferedConfig, builderOverrides = options.builderOverrides;
        if (fs.existsSync(filePath) && fs.statSync(filePath).isDirectory()) {
            var dir = filePath;
            var derivedConfig = {};
            if (fs.existsSync(path.join(dir, 'package.json'))) {
                derivedConfig = inferConfig_1.default(path.join(dir, 'package.json'));
            }
            var candidates = ['.zenrc.json', '.zenrc', '.zenrc.js', 'package.json'];
            for (var _i = 0, candidates_1 = candidates; _i < candidates_1.length; _i++) {
                var fileName = candidates_1[_i];
                var configPath = path.join(dir, fileName);
                if (fs.existsSync(configPath)) {
                    try {
                        var builders = this.readConfig({ filePath: configPath, inferedConfig: derivedConfig, builderOverrides: builderOverrides });
                        if (builders) {
                            return builders;
                        }
                    }
                    catch (e) {
                        e.message = "while processing " + configPath + ": " + e.message;
                        throw e;
                    }
                }
            }
        }
        else {
            var derivedConfig = inferedConfig || inferConfig_1.default(path.join(path.dirname(filePath), 'package.json'));
            var configObject = void 0;
            if (fs.existsSync(filePath)) {
                process.chdir(path.dirname(filePath));
                try {
                    var extname = path.extname(filePath);
                    if (['.json', ''].indexOf(extname) >= 0) {
                        try {
                            configObject = JSON.parse(fs.readFileSync(filePath).toString());
                            if (path.basename(filePath) === 'package.json') {
                                configObject = configObject.zen;
                            }
                        }
                        catch (e) {
                            throw new EnhancedError_1.default("Error parsing " + path.resolve(filePath), e);
                        }
                    }
                    else {
                        var exports_1 = require(path.resolve(filePath));
                        configObject = exports_1 instanceof Function ? exports_1(this.zen) : exports_1;
                    }
                }
                finally {
                    process.chdir(this.zen.cwd);
                }
            }
            return typeof configObject === 'undefined' && !fs.existsSync(filePath)
                ? undefined
                : this._createBuilders(filePath, configObject, derivedConfig, builderOverrides);
        }
    };
    ConfigReader.prototype._createBuilders = function (filePath, config, derivedConfig, builderOverrides) {
        config = this.zen.merge(derivedConfig, config);
        config = config || {};
        config.options = config.options || {};
        var relativePath = path.relative(this.zen.cwd, path.dirname(filePath));
        var builders = {};
        var _a = config.options, stack = _a.stack, plugins = _a.plugins, options = __rest(_a, ["stack", "plugins"]);
        for (var _i = 0, _b = Object.keys(config.builders || {}); _i < _b.length; _i++) {
            var name = _b[_i];
            try {
                var builderVal = config.builders[name];
                var builder = this.zen.mergeWithInStrategy(typeof builderVal === 'object' && builderVal.constructor !== Array
                    ? __assign({}, builderVal) : { stack: builderVal }, builderOverrides);
                if (typeof config.options.stack === 'undefined' && typeof builder.stack === 'undefined') {
                    if (derivedConfig.builders[name]) {
                        builder = this.zen.merge(derivedConfig.builders[name], builder);
                    }
                    else {
                        throw new Error("Builder '" + builder.name + "' has no stack defined.\nIf this is your custom builder, you must define 'stack'\nIf you mean to override options for infered builder, specify its name as a key from the list: " + JSON.stringify(Object.keys(derivedConfig.builders)));
                    }
                }
                builder.stack = new Stack_1.default(config.options.stack || [], typeof builder === 'object' ? builder.stack : builder);
                builder.name = name;
                builder.require = createRequire_1.default(path.resolve(relativePath));
                builder.plugins = (config.plugins || []).concat(builder.plugins || []);
                builder.roles = builder.roles || ['build', 'watch'];
                var merged = merge(options, builder);
                for (var _c = 0, _d = Object.keys(merged); _c < _d.length; _c++) {
                    var key = _d[_c];
                    builder[key] = merged[key];
                }
                var builderId = relativePath + "[" + builder.name + "]";
                builder.id = builderId;
                builder.configPath = filePath;
                builders[builderId] = builder;
                builder.buildDir =
                    builder.backendBuildDir || builder.frontendBuildDir ? undefined : builder.buildDir || 'build';
                builder.nodeDebugger = typeof builder.nodeDebugger !== 'undefined' ? builder.nodeDebugger : true;
                builder.webpackDll = typeof builder.webpackDll !== 'undefined' ? builder.webpackDll : true;
                builder.sourceMap = typeof builder.sourceMap !== 'undefined' ? builder.sourceMap : true;
                builder.minify = typeof builder.minify !== 'undefined' ? builder.minify : true;
                builder.cache =
                    typeof builder.cache === 'string' && builder.cache !== 'auto'
                        ? builder.cache
                        : typeof builder.cache !== 'undefined'
                            ? builder.cache
                            : 'auto';
                if (builder.infered) {
                    builder.dllBuildDir =
                        builder.dllBuildDir ||
                            path.join(typeof builder.cache === 'string' && builder.cache !== 'auto' ? builder.cache : '.cache', 'dll');
                }
                else {
                    builder.dllBuildDir = builder.dllBuildDir || 'build/dll';
                }
                builder.plugins = this.plugins.concat((builder.plugins || []).map(function (pluginName) { return new (require(pluginName))(); }));
            }
            catch (e) {
                e.message = "while creating builder '" + name + "': " + e.message;
                throw e;
            }
        }
        return builders;
    };
    return ConfigReader;
}());
exports.default = ConfigReader;
//# sourceMappingURL=ConfigReader.js.map