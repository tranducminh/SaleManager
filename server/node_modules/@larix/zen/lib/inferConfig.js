"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var createRequire_1 = require("./createRequire");
var getDeps_1 = require("./getDeps");
var Stack_1 = require("./Stack");
var upDirs_1 = require("./upDirs");
var entryExts = ['js', 'jsx', 'ts', 'tsx'];
var entryDirs = ['.', 'src'];
var entryCandidates = [];
var _loop_1 = function (dir) {
    entryCandidates = entryCandidates.concat(entryExts.map(function (ext) { return './' + path.join(dir, 'index.' + ext); }));
};
for (var _i = 0, entryDirs_1 = entryDirs; _i < entryDirs_1.length; _i++) {
    var dir = entryDirs_1[_i];
    _loop_1(dir);
}
var isZenApp = function (pkg) {
    return (Object.keys(pkg.dependencies || {})
        .concat(Object.keys(pkg.devDependencies || {}))
        .indexOf('zen') >= 0 ||
        (pkg.scripts && pkg.scripts.build && pkg.scripts.build.indexOf('zen build') >= 0));
};
exports.default = (function (pkgJsonPath) {
    var _a;
    try {
        var relRequire = createRequire_1.default(path.dirname(pkgJsonPath));
        if (!pkgJsonPath || !fs.existsSync(pkgJsonPath)) {
            return {};
        }
        var pkg = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));
        if (!isZenApp(pkg)) {
            return {};
        }
        var pkgPathList = upDirs_1.default(path.dirname(pkgJsonPath), 'package.json');
        var deps = {};
        for (var _i = 0, pkgPathList_1 = pkgPathList; _i < pkgPathList_1.length; _i++) {
            var pkgPath = pkgPathList_1[_i];
            if (fs.existsSync(pkgPath)) {
                var pkgJson = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
                var requireDep = createRequire_1.default(path.dirname(pkgPath));
                deps = __assign({}, deps, getDeps_1.default(pkgPath, requireDep, {}), (pkgJson.devDependencies || {}));
            }
        }
        var entry = void 0;
        for (var _b = 0, entryCandidates_1 = entryCandidates; _b < entryCandidates_1.length; _b++) {
            var entryPath = entryCandidates_1[_b];
            if (fs.existsSync(path.join(path.dirname(pkgJsonPath), entryPath))) {
                entry = entryPath;
                break;
            }
        }
        if (!entry) {
            throw new Error('Cannot find entry file, tried: ' + entryCandidates);
        }
        var stack = [];
        var isMobile = false;
        if (deps['apollo-server-express'] || deps.express) {
            stack.push('server');
        }
        if (deps['swagger-ui-express'] || deps['swagger-jsdoc']) {
            stack.push('rest');
        }
        if (deps['react-native']) {
            stack.push('android');
            isMobile = true;
        }
        else if (deps['react-dom'] || deps['@angular/core'] || deps.vue) {
            stack.push('web');
        }
        if (relRequire.probe('babel-core') || relRequire.probe('@babel/core')) {
            stack.push('es6');
        }
        stack.push('js');
        if (relRequire.probe('typescript')) {
            stack.push('ts');
        }
        if (deps['apollo-server-express'] || deps['react-apollo'] || deps['apollo-boost'] || deps['apollo-link']) {
            stack.push('apollo');
        }
        if (deps.react) {
            stack.push('react');
        }
        if (deps['@angular/core']) {
            stack.push('angular');
        }
        if (deps.vue) {
            stack.push('vue');
        }
        if (deps['react-native']) {
            stack.push('react-native');
        }
        if (relRequire.probe('styled-components')) {
            stack.push('styled-components');
        }
        if (relRequire.probe('css-loader') && !isMobile) {
            stack.push('css');
        }
        if (relRequire.probe('sass-loader') && !isMobile) {
            stack.push('sass');
        }
        if (relRequire.probe('less-loader') && !isMobile) {
            stack.push('less');
        }
        if (relRequire.probe('@alienfast/i18next-loader')) {
            stack.push('i18next');
        }
        if (relRequire.probe('webpack')) {
            stack.push('webpack');
        }
        var config = void 0;
        var builderDefaults = {
            entry: entry,
            silent: true,
            nodeDebugger: false,
            infered: true
        };
        if (stack.indexOf('react-native') >= 0) {
            var builderAndroid = __assign({ stack: stack }, builderDefaults);
            var iosStack = stack.slice();
            iosStack[stack.indexOf('android')] = 'ios';
            var builderIOS = __assign({ stack: iosStack }, builderDefaults);
            config = {
                builders: {
                    android: builderAndroid,
                    ios: builderIOS
                },
                options: {
                    defines: {
                        __DEV__: process.env.NODE_ENV !== 'production'
                    }
                }
            };
        }
        else {
            var platform_1 = new (Stack_1.default.bind.apply(Stack_1.default, [void 0].concat(stack)))().platform;
            var builder = __assign({ stack: stack }, builderDefaults);
            config = {
                builders: (_a = {},
                    _a[platform_1] = builder,
                    _a.test = {
                        stack: stack.map(function (tech) { return (tech !== platform_1 ? tech : 'server'); }),
                        roles: ['test'],
                        defines: {
                            __TEST__: true
                        }
                    },
                    _a)
            };
        }
        return config;
    }
    catch (e) {
        e.message = "while infering config for: " + pkgJsonPath + ": " + e.message;
        throw e;
    }
});
//# sourceMappingURL=inferConfig.js.map